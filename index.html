<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Lyen Cc</title>
  <meta name="author" content="Lyen">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Lyen Cc"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Lyen Cc" type="application/atom+xml">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-368771XX-X']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>

<body>
  <header id="header" class='normal_mode'>
    <nav id="main-nav">
  <ul class='container'>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
  </header>
  <div id="content" class="container">
    <div id="cover">
	<div id="profile" alt="http://www.33lc.com/article/UploadPic/2012-7/20127291041962908.jpg">
		<a href="/">
			<div class="logo">
				<img src="/logo.png" alt="Profile Picture">
			</div>
			<div id="title">Lyen Cc</div>
		</a>

		
		 <ul class="my-socials">
  
  <li>
  	<a href="https://github.com/BluceLyen" class="github" target="_blank">
  		<i class="fa fa-github"></i>
  	</a>
  </li>
  
  <li>
  	<a href="http://weibo.com/u/2530759420/home?topnav=1&wvr=6" class="weibo" target="_blank">
  		<i class="fa fa-weibo"></i>
  	</a>
  </li>
  
 
</ul>
	</div>
</div>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2016-07-03T05:19:31.482Z"><a href="/2016/07/03/caculating/">Dom., Jul. 3 2016, 1:19:31 pm</a></time>

  
    <h1 class="title"><a href="/2016/07/03/caculating/">能源分项计量流式处理系统设计与开发</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h2 id="1-设计思路">1.设计思路</h2><h3 id="1-1问题分析">1.1问题分析</h3><p>分项计量,对每隔5s(可扩展为15s,15min,1h,1d,1month)从服务器端发送过来的格式为xml的能耗数据信息进行解析,备份原始数据信息并实时计算分项能耗的更新值并且对更新信息做持久化.</p>
<h3 id="1-2设计目标">1.2设计目标</h3><h4 id="1-2-1_数据接收">1.2.1 数据接收</h4><p>数据接收采用Spark Streaming自定义Receiver,Kafka,Flume + Kafka,此处采用Spark Streaming自定义Receiver</p>
<h4 id="1-2-2_数据备份">1.2.2 数据备份</h4><p>将从服务器端接收到的xml数据信息进行解析,提取重要信息存入Hbase实现原始数据备份也可以用于数据挖掘与分析</p>
<h4 id="1-2-3_数据拆分计算">1.2.3 数据拆分计算</h4><p>将服务器端接收到的xml数据信息进行解析,提取数据信息中的分项能耗并进行计算其更新值.</p>
<h4 id="1-2-4_数据持久化">1.2.4 数据持久化</h4><p>将每个时间段计算的分项能耗更新值持久化于Mysql.</p>
<h2 id="2-系统实现">2.系统实现</h2><h3 id="2-1结构设计图">2.1结构设计图</h3><p><img src="/caculating/design.png" alt=""></p>
<h3 id="2-2接收数据">2.2接收数据</h3><ul>
<li>服务器端每隔5s发送一次数据,数据为xml文件<h3 id="2-2-1数据格式">2.2.1数据格式</h3><pre><code> &lt;root&gt;
     &lt;common&gt;
         &lt;building_id&gt;<span class="number">510107</span>D004&lt;/building_id&gt;
         &lt;gateway_id&gt;<span class="number">510107</span>D00401&lt;/gateway_id&gt;
         &lt;type&gt;peroid&lt;/type&gt;
     &lt;/common&gt;
     &lt;data operation=<span class="string">" query/reply/report/continuous/continuous_ack"</span>&gt;
         &lt;sequence&gt;<span class="number">2016</span>-<span class="number">05</span>-<span class="number">24</span>-<span class="number">10</span>-<span class="number">56</span>-<span class="number">46</span>&lt;/sequence&gt;
         &lt;parser&gt;no&lt;/parser&gt;
         &lt;time&gt;<span class="number">1464058606</span>&lt;/time&gt;
         &lt;total&gt;<span class="number">0</span>&lt;/total&gt;
         &lt;current&gt;<span class="number">0</span>&lt;/current&gt;
         &lt;meter id=<span class="string">"510107D004010002"</span>&gt;
              &lt;<span class="function"><span class="keyword">function</span> <span class="title">id</span>=</span><span class="string">"51010700000101"</span> <span class="built_in">error</span>=<span class="string">"0"</span> coding=<span class="string">"510107D00401A10"</span>&gt;<span class="number">0.037370</span>&lt;/<span class="function"><span class="keyword">function</span>&gt;</span>
              &lt;<span class="function"><span class="keyword">function</span> <span class="title">id</span>=</span><span class="string">"51010700000102"</span> <span class="built_in">error</span>=<span class="string">"0"</span> coding=<span class="string">"510107D00401A10"</span>&gt;<span class="number">223.499924</span>&lt;/<span class="function"><span class="keyword">function</span>&gt;</span>
              &lt;<span class="function"><span class="keyword">function</span> <span class="title">id</span>=</span><span class="string">"51010700000103"</span> <span class="built_in">error</span>=<span class="string">"0"</span> coding=<span class="string">"510107D00401A10"</span>&gt;<span class="number">205.601120</span>&lt;/<span class="function"><span class="keyword">function</span>&gt;</span>
              &lt;<span class="function"><span class="keyword">function</span> <span class="title">id</span>=</span><span class="string">"51010700000104"</span> <span class="built_in">error</span>=<span class="string">"0"</span> coding=<span class="string">"510107D00401A10"</span>&gt;<span class="number">98.742043</span>&lt;/<span class="function"><span class="keyword">function</span>&gt;</span>
              &lt;<span class="function"><span class="keyword">function</span> <span class="title">id</span>=</span><span class="string">"51010700000105"</span> <span class="built_in">error</span>=<span class="string">"0"</span> coding=<span class="string">"510107D00401A10"</span>&gt;<span class="number">2.788278</span>&lt;/<span class="function"><span class="keyword">function</span>&gt;</span>
              &lt;<span class="function"><span class="keyword">function</span> <span class="title">id</span>=</span><span class="string">"51010700000106"</span> <span class="built_in">error</span>=<span class="string">"0"</span> coding=<span class="string">"510107D00401A10"</span>&gt;<span class="number">0.323411</span>&lt;/<span class="function"><span class="keyword">function</span>&gt;</span>
         &lt;/meter&gt;&lt;meter id=<span class="string">"510107D004010001"</span>&gt;
              &lt;<span class="function"><span class="keyword">function</span> <span class="title">id</span>=</span><span class="string">"51010700000101"</span> <span class="built_in">error</span>=<span class="string">"0"</span> coding=<span class="string">"510107D00401A10"</span>&gt;<span class="number">0.013402</span>&lt;/<span class="function"><span class="keyword">function</span>&gt;</span>
              &lt;<span class="function"><span class="keyword">function</span> <span class="title">id</span>=</span><span class="string">"51010700000102"</span> <span class="built_in">error</span>=<span class="string">"0"</span> coding=<span class="string">"510107D00401A10"</span>&gt;<span class="number">224.974243</span>&lt;/<span class="function"><span class="keyword">function</span>&gt;</span>
              &lt;<span class="function"><span class="keyword">function</span> <span class="title">id</span>=</span><span class="string">"51010700000103"</span> <span class="built_in">error</span>=<span class="string">"0"</span> coding=<span class="string">"510107D00401A10"</span>&gt;<span class="number">208.038010</span>&lt;/<span class="function"><span class="keyword">function</span>&gt;</span>
              &lt;<span class="function"><span class="keyword">function</span> <span class="title">id</span>=</span><span class="string">"51010700000104"</span> <span class="built_in">error</span>=<span class="string">"0"</span> coding=<span class="string">"510107D00401A10"</span>&gt;<span class="number">98.111786</span>&lt;/<span class="function"><span class="keyword">function</span>&gt;</span>
              &lt;<span class="function"><span class="keyword">function</span> <span class="title">id</span>=</span><span class="string">"51010700000105"</span> <span class="built_in">error</span>=<span class="string">"0"</span> coding=<span class="string">"510107D00401A10"</span>&gt;<span class="number">2.786295</span>&lt;/<span class="function"><span class="keyword">function</span>&gt;</span>
              &lt;<span class="function"><span class="keyword">function</span> <span class="title">id</span>=</span><span class="string">"51010700000106"</span> <span class="built_in">error</span>=<span class="string">"0"</span> coding=<span class="string">"510107D00401A10"</span>&gt;<span class="number">0.307666</span>&lt;/<span class="function"><span class="keyword">function</span>&gt;</span>
         &lt;/meter&gt;
     &lt;/data&gt;
&lt;/root&gt;
</code></pre><h3 id="2-2-2数据说明">2.2.2数据说明</h3><pre><code>building_id:楼栋编号
gateway_id:采集器编号
type:能耗远传数据包的类型
能耗远传 
操作有4种类型
query:服务器查询数据采集器，不需要子元素
reply:采集器对服务器查询的应答
report:采集器定时上报的能耗数据
continuous:采集器断点续传的能耗数据
continuous_ack:全部续传数据包接收完成后，服务器对断点续传的应答，不需要子元素
元素有5种类型
sequence元素:采集器向服务器发送数据的序号
parser元素:向服务器发送的数据是否经采集器解析过
time元素:数据采集时间
total元素:断点续传时有效，表示需要断点续传数据包的总数
current元素:断点续传时有效，表示当前断点续传数据包的编号
port元素:计量装置的设备号，具有id属性
function元素:每个计量装置的具体采集功能，具有下列3种属性，
id属性:计量装置的数据采集功能编号（供多功能电能表使用）
coding属性:能耗数据分类/分项编码
error属性:该功能出现错误的状态码，0表示没有错误
</code></pre></li>
</ul>
<h3 id="2-2-3核心代码">2.2.3核心代码</h3><pre><code><span class="keyword">package</span> com.calculating.pro
<span class="keyword">import</span> java.io.{<span class="type">InputStreamReader</span>, <span class="type">BufferedReader</span>}
<span class="keyword">import</span> org.apache.spark.<span class="type">Logging</span>
<span class="keyword">import</span> org.apache.spark.storage.<span class="type">StorageLevel</span>
<span class="keyword">import</span> org.apache.spark.streaming.receiver.<span class="type">Receiver</span>
<span class="keyword">import</span> java.net.<span class="type">ServerSocket</span>

<span class="class"><span class="keyword">class</span> <span class="title">CustomReceiver</span>(</span>port:<span class="type">Int</span>) <span class="keyword">extends</span> <span class="type">Receiver</span>[<span class="type">String</span>](<span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK_2</span>) <span class="keyword">with</span> <span class="type">Logging</span>{
  <span class="function"><span class="keyword">def</span> <span class="title">onStart</span>(</span>){
    <span class="comment">// 启动接收数据的线程</span>
    <span class="keyword">new</span> <span class="type">Thread</span>(<span class="string">"Socket Receiver"</span>){<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span>(</span>) { receive() }}.start()
  }
  <span class="function"><span class="keyword">def</span> <span class="title">onStop</span>(</span>) {
    <span class="comment">// 这里没有调用Receiver的线程</span>
    <span class="comment">//如果自身isStopped()返回的是false则停止</span>
  }
  <span class="comment">/** 创建一个套接字连接和接收数据，直到Receiver被停止 */</span>
  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span>(</span>) {
    <span class="keyword">var</span> socket: <span class="type">ServerSocket</span> = <span class="literal">null</span>
    <span class="keyword">var</span> userInput: <span class="type">String</span> = <span class="literal">null</span>
    <span class="keyword">try</span> {
      <span class="comment">// 连接主机:端口</span>
      socket = <span class="keyword">new</span> <span class="type">ServerSocket</span>(port)
      <span class="comment">//直到停止或连接中断否则继续读取</span>
      <span class="function"><span class="keyword">val</span> <span class="title">reader</span> =</span> <span class="keyword">new</span> <span class="type">BufferedReader</span>(<span class="keyword">new</span> <span class="type">InputStreamReader</span>(socket.accept().getInputStream(), <span class="string">"UTF-8"</span>))
      userInput = reader.readLine()
      <span class="keyword">while</span>(!isStopped &amp;&amp; userInput != <span class="literal">null</span>) {
        store(userInput)
        userInput = reader.readLine()
      }
      reader.close()
      socket.close()
      <span class="comment">// 当服务器再次激活时，重新启动重新连接</span>
      restart(<span class="string">"Trying to connect again"</span>)
    } <span class="keyword">catch</span> {
      <span class="keyword">case</span> e: java.net.<span class="type">ConnectException</span> =&gt;
        <span class="comment">// 如果不能连接到服务器则重新启动</span>
        restart(<span class="string">"Error connecting to "</span> +<span class="string">":"</span> + port, e)
      <span class="keyword">case</span> t: <span class="type">Throwable</span> =&gt;
        <span class="comment">// 如果出现错误则重新启动</span>
        restart(<span class="string">"Error receiving data"</span>, t)
    }  }
}
</code></pre><h3 id="2-3数据封装">2.3数据封装</h3><h4 id="2-3-1_xmlToObject">2.3.1 xmlToObject</h4><ul>
<li><p>将xml数据转化为java对象封装在一个Root类中与xml文件结构相对应</p>
<h4 id="2-3-2_核心代码">2.3.2 核心代码</h4><p>  import java.io.Serializable;<br>  import java.util.ArrayList;<br>  import java.util.List;<br>  import com.thoughtworks.xstream.XStream;<br>  import com.thoughtworks.xstream.converters.extended.ToAttributedValueConverter;<br>  import com.thoughtworks.xstream.io.xml.StaxDriver;</p>
<p>  public class ParseXml implements Serializable{</p>
<pre><code>private <span class="literal">static</span> <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;

public Root xmlToObject(<span class="built_in">String</span> xml){
    <span class="comment">// 通过它传递一个StaxDriver创建XStream对象。StaxDriver使用SAX解析器(可从Java6)，一个快速的XML解析器。</span>
    XStream xstream = <span class="keyword">new</span> XStream(<span class="keyword">new</span> StaxDriver());
    <span class="comment">//类混叠是用来创建一个类的XML完全限定名称的别名。</span>
    xstream.alias(<span class="string">"root"</span>, Root.<span class="keyword">class</span>);
    xstream.alias(<span class="string">"common"</span>, Common.<span class="keyword">class</span>);
    xstream.alias(<span class="string">"data"</span>, Data.<span class="keyword">class</span>);
    xstream.alias(<span class="string">"meter"</span>, Meter.<span class="keyword">class</span>);
    xstream.alias(<span class="string">"function"</span>, <span class="built_in">Function</span>.<span class="keyword">class</span>);
    <span class="comment">//ps通过此方法才能获得每个function的值</span>
    xstream.registerConverter(<span class="keyword">new</span> ToAttributedValueConverter(<span class="built_in">Function</span>.<span class="keyword">class</span>, xstream.getMapper(),xstream.getReflectionProvider(), xstream.getConverterLookup(), <span class="string">"value"</span>));
  <span class="comment">//隐式集合混叠时使用的集合是表示在XML无需显示根</span>
    xstream.addImplicitCollection(Data.<span class="keyword">class</span>, <span class="string">"meters"</span>);
    xstream.addImplicitCollection(Meter.<span class="keyword">class</span>, <span class="string">"functions"</span>);
    <span class="comment">// 属性混叠用于创建一个成员变量作为XML属性序列化</span>
    xstream.useAttributeFor(Data.<span class="keyword">class</span>, <span class="string">"operation"</span>);
    xstream.useAttributeFor(Meter.<span class="keyword">class</span>, <span class="string">"id"</span>);
    xstream.useAttributeFor(<span class="built_in">Function</span>.<span class="keyword">class</span>, <span class="string">"id"</span>);
    xstream.useAttributeFor(<span class="built_in">Function</span>.<span class="keyword">class</span>, <span class="string">"error"</span>);
    xstream.useAttributeFor(<span class="built_in">Function</span>.<span class="keyword">class</span>, <span class="string">"coding"</span>);
    Root root = (Root) xstream.fromXML(xml);
    <span class="keyword">return</span> root;
}
<span class="class"><span class="keyword">class</span> <span class="title">Root</span> </span>{
    Common common;
    Data data;
}
<span class="class"><span class="keyword">class</span> <span class="title">Common</span> </span>{
    <span class="built_in">String</span> building_id;
    <span class="built_in">String</span> gateway_id;
    <span class="built_in">String</span> type;
}
<span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>{
    <span class="built_in">String</span> operation;
    <span class="built_in">String</span> sequence;
    <span class="built_in">String</span> parser;
    Long time;
    Long total;
    Long current;
    <span class="built_in">List</span>&lt;Meter&gt; meters = <span class="keyword">new</span> ArrayList&lt;Meter&gt;();
}
<span class="class"><span class="keyword">class</span> <span class="title">Meter</span> </span>{
    <span class="built_in">String</span> id;
    <span class="built_in">List</span>&lt;<span class="built_in">Function</span>&gt; functions = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">Function</span>&gt;();
}
<span class="class"><span class="keyword">class</span> <span class="title">Function</span> </span>{
    <span class="built_in">String</span> id;
    <span class="built_in">String</span> error;
    <span class="built_in">String</span> coding;
    <span class="built_in">String</span> value;
}
</code></pre><p>  }</p>
<h3 id="2-4备份数据">2.4备份数据</h3><h4 id="2-4-1Hbase_RowKey设计">2.4.1Hbase RowKey设计</h4><p>meter_id + time + function_id</p>
<h4 id="2-4-2columnFamilys设计">2.4.2columnFamilys设计</h4><p>列族:fuinction族和data族</p>
</li>
<li><p>function族包括(“error”,”coding”,”value”)</p>
</li>
<li>data族包括(“sequence”,”parser”,”operation”,”total”,”current”,”type”)</li>
</ul>
<h4 id="2-4-3核心代码">2.4.3核心代码</h4><pre><code>def inputData<span class="params">(tableName: String, rowKey: String, columnFamily: Array[String], columns: Array[String], values: Array[String])</span> = {
  val table = new HTable<span class="params">(config, tableName)</span>;
  <span class="comment">/*
  * 数据格式:
  *  familys = Array("function","data")  
  *  columns = Array("error","coding","value","sequence","parser","operation","total","current","type")
   */</span>
  val puts = new Put<span class="params">(Bytes.toBytes<span class="params">(rowKey)</span>)</span>

  puts.addColumn<span class="params">(Bytes.toBytes<span class="params">(columnFamily<span class="params">(<span class="number">0</span>)</span>)</span>, Bytes.toBytes<span class="params">(columns<span class="params">(<span class="number">0</span>)</span>)</span>, Bytes.toBytes<span class="params">(values<span class="params">(<span class="number">0</span>)</span>)</span>)</span>
  puts.addColumn<span class="params">(Bytes.toBytes<span class="params">(columnFamily<span class="params">(<span class="number">0</span>)</span>)</span>, Bytes.toBytes<span class="params">(columns<span class="params">(<span class="number">1</span>)</span>)</span>, Bytes.toBytes<span class="params">(values<span class="params">(<span class="number">1</span>)</span>)</span>)</span>
  puts.addColumn<span class="params">(Bytes.toBytes<span class="params">(columnFamily<span class="params">(<span class="number">0</span>)</span>)</span>, Bytes.toBytes<span class="params">(columns<span class="params">(<span class="number">2</span>)</span>)</span>, Bytes.toBytes<span class="params">(values<span class="params">(<span class="number">2</span>)</span>)</span>)</span>

  puts.addColumn<span class="params">(Bytes.toBytes<span class="params">(columnFamily<span class="params">(<span class="number">1</span>)</span>)</span>, Bytes.toBytes<span class="params">(columns<span class="params">(<span class="number">3</span>)</span>)</span>, Bytes.toBytes<span class="params">(values<span class="params">(<span class="number">3</span>)</span>)</span>)</span>
  puts.addColumn<span class="params">(Bytes.toBytes<span class="params">(columnFamily<span class="params">(<span class="number">1</span>)</span>)</span>, Bytes.toBytes<span class="params">(columns<span class="params">(<span class="number">4</span>)</span>)</span>, Bytes.toBytes<span class="params">(values<span class="params">(<span class="number">4</span>)</span>)</span>)</span>
  puts.addColumn<span class="params">(Bytes.toBytes<span class="params">(columnFamily<span class="params">(<span class="number">1</span>)</span>)</span>, Bytes.toBytes<span class="params">(columns<span class="params">(<span class="number">5</span>)</span>)</span>, Bytes.toBytes<span class="params">(values<span class="params">(<span class="number">5</span>)</span>)</span>)</span>
  puts.addColumn<span class="params">(Bytes.toBytes<span class="params">(columnFamily<span class="params">(<span class="number">1</span>)</span>)</span>, Bytes.toBytes<span class="params">(columns<span class="params">(<span class="number">6</span>)</span>)</span>, Bytes.toBytes<span class="params">(values<span class="params">(<span class="number">6</span>)</span>)</span>)</span>
  puts.addColumn<span class="params">(Bytes.toBytes<span class="params">(columnFamily<span class="params">(<span class="number">1</span>)</span>)</span>, Bytes.toBytes<span class="params">(columns<span class="params">(<span class="number">7</span>)</span>)</span>, Bytes.toBytes<span class="params">(values<span class="params">(<span class="number">7</span>)</span>)</span>)</span>
  puts.addColumn<span class="params">(Bytes.toBytes<span class="params">(columnFamily<span class="params">(<span class="number">1</span>)</span>)</span>, Bytes.toBytes<span class="params">(columns<span class="params">(<span class="number">8</span>)</span>)</span>, Bytes.toBytes<span class="params">(values<span class="params">(<span class="number">8</span>)</span>)</span>)</span>
  table.put<span class="params">(puts)</span>
}
</code></pre><h3 id="2-5_数据拆分与计算">2.5 数据拆分与计算</h3><h4 id="2-5-1数据拆分">2.5.1数据拆分</h4><ul>
<li>接收到的xml文件格式的数据转化成了类的对象</li>
<li>拆分所要做的就是从封装的对象中获取我们即将计算所需要需要的元素<h4 id="2-5-2拆分核心代码">2.5.2拆分核心代码</h4>   //定义一个缓冲数据存放拆分所获取的值<br>   val dataParsed = new ArrayBuffer<a href="">Calculating</a><br>   val xmlObject = ParseXml.xmlToObject(xmlOb)<br>   val <code>type</code> = xmlObject.common.<code>type</code><br>   val building_id = xmlObject.common.building_id<br>   val operation = xmlObject.data.operation<br>   val sequence = xmlObject.data.sequence<br>   val parser = xmlObject.data.parser<br>   val time = xmlObject.data.time<br>   val total = xmlObject.data.total<br>   val current = xmlObject.data.current<br>   //遍历meter和function取得相应值<br>   val meterList: java.util.List[Meter] = xmlObject.data.meters<br>   var meter: Meter = null<br>   var function: Function = null<br>   val meterIter = meterList.iterator()<br>   while (meterIter.hasNext) {<pre><code> meter = meterIter.next()
 val funIter = meter.functions.iterator()
 <span class="keyword">while</span> (funIter.hasNext) {
   <span class="function"><span class="keyword">function</span></span> = funIter.next()
   val energyItemCode = <span class="function"><span class="keyword">function</span>.<span class="title">coding</span></span>.substring(<span class="function"><span class="keyword">function</span>.<span class="title">coding</span></span>.length() - <span class="number">5</span>, <span class="function"><span class="keyword">function</span>.<span class="title">coding</span></span>.length())
   //建筑id,能源代号,能源分项号,采集表表号,时间,能源分项数据
   val computeData = Calculating(building_id, energyItemCode, <span class="function"><span class="keyword">function</span>.<span class="title">id</span></span>, meter.id, time, <span class="function"><span class="keyword">function</span>.<span class="title">value</span></span>.toFloat)
   dataParsed += computeData
}
}
</code></pre><h4 id="2-5-3数据更新计算">2.5.3数据更新计算</h4></li>
<li>将建筑id/能源代号/能源分项号/采集表表号<strong>作为Key</strong>,时间/能耗数据<strong>作为Value</strong>,这样就能保证每一次接收过来的数据与上一次的数据<strong>一一对应</strong></li>
<li>更新分项能耗数据,将此次的值与上一次的值做减法即可得到<strong>当前能耗数据</strong></li>
<li><p>将建筑id/能源代号/能源分项号/时间<strong>作为Key</strong>,能耗数据<strong>作为Value</strong>,目的是为了合并同当前一个数据源中不同表的能耗数据,得到最终能耗数据更新值</p>
<h4 id="2-5-4计算核心代码">2.5.4计算核心代码</h4><p>   def runningStream = {<br>  // 创建一个新的StreamingContext</p>
<pre><code>val ssc = new <span class="function"><span class="title">StreamingContext</span><span class="params">(sc, Seconds(<span class="number">5</span>)</span></span>)
ssc.<span class="function"><span class="title">checkpoint</span><span class="params">(<span class="string">"hdfs://master:9000/test"</span>)</span></span>
val lines = ssc.<span class="function"><span class="title">receiverStream</span><span class="params">(new CustomReceiver(<span class="number">25535</span>)</span></span>).<span class="function"><span class="title">cache</span><span class="params">()</span></span>
</code></pre><p>  //解析xml返回所需数据</p>
<pre><code>  val dataComputing = lines.glom<span class="params">()</span>.map { x =&gt;
<span class="comment">//glom 把每个分区的数据合并成一个Array,目的在于把DStream[String]离散流转变为DStream[Array[String]]</span>
<span class="comment">//fold 把离散流的字符串聚合成原本的xml格式的字符串</span>
    x.foldLeft<span class="params">(<span class="string">""</span>)</span><span class="params">(<span class="params">(a, b)</span> =&gt; a + <span class="string">"\n"</span> + b)</span>.trim<span class="params">()</span>
  }.flatMap<span class="params">(splitXml<span class="params">(_)</span>)</span>.map { x =&gt;
    <span class="params">(<span class="params">(x.building_id, x.energyItemCode, x.function_id, x.merter_id)</span>, <span class="params">(x.time, x.function_value)</span>)</span>
  }.updateStateByKey<span class="params">(updateFunc _)</span>.map { x =&gt;
<span class="params">(<span class="params">(x._1._1, x._1._2, x._1._3, x._2._1)</span>, x._2._2)</span>
   }.reduceByKey<span class="params">(_ + _)</span>.cache<span class="params">()</span>
  }
 ssc.start<span class="params">()</span>
 ssc.awaitTermination<span class="params">()</span>
</code></pre><p>   }</p>
<p>  //更新函数<br>   def updateFunction(newValues: Seq[(Long, Float)], preValue: Option[(Long, Float)]): Option[((Long, Float))] = {</p>
<pre><code>  val prevalue = preValue.map<span class="params">(x =&gt; x._2)</span>.getOrElse<span class="params">(<span class="number">0</span>F)</span>
  val newvalue = newValues.map<span class="params">(x =&gt; x._2)</span>.sum
  val interval = newvalue - prevalue
  var re = <span class="params">(<span class="number">0</span>l,<span class="number">0</span>f)</span>
  <span class="comment">//5秒,15秒,1小时等更新一次</span>
  <span class="keyword">if</span> <span class="params">(interval == <span class="number">5</span>l)</span> {
     re = <span class="params">(newValues.map<span class="params">(x =&gt; x._1)</span>.sum, <span class="params">(interval)</span>)</span>
  }<span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(interval == <span class="number">90</span>l)</span> {
     re = <span class="params">(newValues.map<span class="params">(x =&gt; x._1)</span>.sum, <span class="params">(interval)</span>)</span>
  }<span class="keyword">else</span> <span class="keyword">if</span><span class="params">(interval == <span class="number">3600</span>l)</span>{
       re = <span class="params">(newValues.map<span class="params">(x =&gt; x._1)</span>.sum, <span class="params">(interval)</span>)</span>
  }
  Some<span class="params">(re)</span>
}
</code></pre><h3 id="2-6_数据持久化">2.6 数据持久化</h3><h4 id="2-6-1Mysql_数据库设计">2.6.1Mysql 数据库设计</h4><p><img src="/caculating/database.png" alt=""></p>
<h4 id="2-6-2核心代码">2.6.2核心代码</h4><p>   def insertData(data:Array[String]) = {</p>
<pre><code> var conn: Connection = null
 var ps: PreparedStatement = null
 <span class="comment">//F_ResultID建筑代码10位+"1"+9位流水号,总长度为20</span>
 val sql = <span class="string">"insert into t_ec_energyitemresulttest(F_ResultID,F_BuildID,F_EnergyItemCode,F_StartTime,F_EndTime,F_Value,F_EquValue,F_state) values (?,?,?,?,?,?,?,?)"</span>
 try {
   <span class="comment">//mysql 用户名为root,密码为空(没设置密码)</span>
   conn = DriverManager.getConnection<span class="params">(<span class="string">"jdbc:mysql://master:3306/fromXml?user=root"</span>, new Properties<span class="params">()</span>)</span>
   ps = conn.prepareStatement<span class="params">(sql)</span>
   ps.setString<span class="params">(<span class="number">1</span>, data<span class="params">(<span class="number">0</span>)</span>)</span><span class="comment">//F_ResultID</span>
   ps.setString<span class="params">(<span class="number">2</span>, data<span class="params">(<span class="number">1</span>)</span>)</span><span class="comment">//F_BuildID</span>
   <span class="comment">//F_EnergyItemCode = function.coding.substring(function.coding.length() - 5, function.coding.length())</span>
   ps.setString<span class="params">(<span class="number">3</span>, data<span class="params">(<span class="number">2</span>)</span>)</span><span class="comment">//F_EnergyItemCode</span>
   ps.setTimestamp<span class="params">(<span class="number">4</span>, new Timestamp<span class="params">(data<span class="params">(<span class="number">3</span>)</span>.toLong)</span>)</span>
   ps.setTimestamp<span class="params">(<span class="number">5</span>, new Timestamp<span class="params">(data<span class="params">(<span class="number">3</span>)</span>.toLong + <span class="number">5</span>)</span>)</span>
   ps.setFloat<span class="params">(<span class="number">6</span>, data<span class="params">(<span class="number">4</span>)</span>.toFloat)</span>
   ps.setFloat<span class="params">(<span class="number">7</span>, data<span class="params">(<span class="number">4</span>)</span>.toFloat * <span class="number">0.1229</span>f)</span>
   ps.setInt<span class="params">(<span class="number">8</span>, new Integer<span class="params">(<span class="number">1</span>)</span>)</span><span class="comment">//0无效数据,1有效数据</span>
   ps.executeUpdate<span class="params">()</span>
} catch {
 case e: Exception =&gt; println<span class="params">(e.fillInStackTrace<span class="params">()</span>)</span>
} finally {
   <span class="keyword">if</span> <span class="params">(ps != null)</span> ps.close<span class="params">()</span>
   <span class="keyword">if</span> <span class="params">(conn != null)</span> conn.close<span class="params">()</span>
}
</code></pre><p>   }</p>
<h4 id="2-7_数据流处理运行效果">2.7 数据流处理运行效果</h4><p><img src="/caculating/exp.png" alt=""></p>
<h2 id="3-总结">3.总结</h2><p>Spark Streaming数据流式处理,通过Spark Streaming接收数据,设置数据检查点(CheckPoint目的是为了发生突发状况时帮助数据恢复更快的恢复计算),拆分数据,数据处理及计算,了解了Spark Streaming的详细工作流程除此之外还涉及到了Hbase数据存储此处用于备份(备份原始数据可用于数据灾难恢复和数据挖掘与分析)和Mysql持久化处理好的数据用于上报相关部门,存在的不足是在Hbase数据存储方面没有详细设计预分区和数据散列,因为单机实验与分区没有什么区别,若是在集群中就要并且必须设计好与分区和散列防止数据写入热点.</p>
</li>
</ul>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2016/07/03/caculating/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://blucelyen.github.io/2016/07/03/caculating/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2016/07/03/caculating/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2016-07-03T02:52:14.397Z"><a href="/2016/07/03/FPGrowth/">Dom., Jul. 3 2016, 10:52:14 am</a></time>

  
    <h1 class="title"><a href="/2016/07/03/FPGrowth/">FPGrowth算法</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h3 id="关联分析">关联分析</h3><p>1.关联分析又称关联挖掘，就是在交易数据、关系数据或其他信息载体中，查找存在于项目集合或对象集合之间的频繁模式、关联、相关性或因果结构。或者说，关联分析是发现交易数据库中不同商品（项）之间的联系。</p>
<h3 id="关联分析之FP-growth算法">关联分析之FP-growth算法</h3><h4 id="算法简介">算法简介</h4><p>基于频繁模式树（Frequent Pattern Tree，简称为FP-tree）的发现频繁模式的算法FP-growth。在FP-growth算法中，通过两次扫描事务数据库，把每个事务所包含的频繁项目按其支持度降序压缩存储到FP—tree中。在以后发现频繁模式的过程中，不需要再扫描事务数据库，而仅在FP-Tree中进行查找即可，并通过递归调用FP-growth的方法来直接产生频繁模式，因此在整个发现过程中也不需产生候选模式。该算法克服了<a href="http://baike.baidu.com/link?url=_a3umNjFJ9FBuvd6jJO5N8Q7cdX5Q2VZT0hnQ9sJb3kgYOmvfL-NkSI19Ia2MZo4kNExoy1E_LhysZUNX6eqtK" target="_blank" rel="external">Apriori算法</a>中存在的可能产生大量的候选集,以及可能需要重复扫描数据库两个问题．在执行效率上也明显好于Apriori算法。</p>
<h4 id="关联规则的相关术语">关联规则的相关术语</h4><p>1.项与项集</p>
<p>这是一个集合的概念，在一篮子商品中的一件消费品即为一项（Item），则若干项的集合为项集，如{啤酒，尿布}构成一个二元项集。<br>2.关联规则</p>
<p>一般记为的形式，X为先决条件，Y为相应的关联结果，用于表示数据内隐含的关联性。如：表示购买了尿布的消费者往往也会购买啤酒。</p>
<p>ps:关联性强度如何，由三个概念——支持度、置信度、提升度来控制和评价。</p>
<p> 例：有10000个消费者购买了商品，其中购买尿布1000个，购买啤酒2000个，购买面包500个，同时购买尿布和啤酒800个，同时购买尿布和面包100个。</p>
<p>3.支持度（Support）</p>
<p>支持度是指在所有项集中{X, Y}出现的可能性，即项集中同时含有X和Y的概率：</p>
<p>该指标作为建立强关联规则的第一个门槛，衡量了所考察关联规则在“量”上的多少。通过设定最小阈值（minsup），剔除“出镜率”较低的无意义规则，保留出现较为频繁的项集所隐含的规则。</p>
<p>设定最小阈值为5%，由于{尿布，啤酒}的支持度为800/10000=8%，满足基本输了要求，成为频繁项集，保留规则；而{尿布，面包}的支持度为100/10000=1%，被剔除。</p>
<p>4.置信度（Confidence）</p>
<p>置信度表示在先决条件X发生的条件下，关联结果Y发生的概率：</p>
<p>这是生成强关联规则的第二个门槛，衡量了所考察的关联规则在“质”上的可靠性。相似的，我们需要对置信度设定最小阈值（mincon）来实现进一步筛选。</p>
<p>具体的，当设定置信度的最小阈值为70%时，置信度为800/1000=80%，而的置信度为800/2000=40%，被剔除。</p>
<p>5.提升度（lift）</p>
<p>提升度表示在含有X的条件下同时含有Y的可能性与没有X这个条件下项集中含有Y的可能性之比：公式为confidence(artichok =&gt; cracker)/support(cracker) = 80%/50% = 1.6。该指标与置信度同样衡量规则的可靠性，可以看作是置信度的一种互补指标。</p>
<h4 id="算法原理">算法原理</h4><h5 id="原理">原理</h5><p>FP-Growth(频繁模式增长)算法采取分治策略：将提供频繁项集的数据库压缩到一棵频繁模式树（FP-Tree），但仍保留项集关联信息；该算法和Apriori算法最大的不同有两点：第一，不产生候选集，第二，只需要两次遍历数据库，大大提高了效率。因为FP树蕴涵了所有的频繁项集,所以其后的频繁项集的挖掘只需要在FP树上进行,而不需要再扫描数据库.</p>
<h5 id="流程">流程</h5><p>1.第一次扫描数据库得到一维频繁项集</p>
<p>2.第二次扫描数据库是利用一维频繁项集过滤数据</p>
<p>3.挖掘FP树,即针对FP树挖掘频繁模式和关联规则</p>
<h5 id="算法举例">算法举例</h5><p>a.假设频繁项集阀值为3,第一次扫描数据库时计算每个项目的出现的次数并过滤</p>
<p><img src="/FPpic/fp01" alt=""></p>
<p>b.把达到阀值的项目按照出现的次数从多到少排序,如果几个项目出现的次数相同,就随机排列得到一维频繁项集:</p>
<p>##&lt;(f:4),(c:4),(a:3),(b:3)(m:3),(p:3)&gt;<br>c.建立FP树</p>
<ul>
<li>根节点定义为null</li>
<li>针对事务集的每条事务进行插入节点操作,每条事务的项目作为一个节点,每个节点包含一个名称,一个次数属性</li>
<li>若插入的事务前面n个项目在树中有相同路径,则不建立新节点,而是直接把相同路径包含的节点的数目加1即可</li>
<li>若插入的事务没有项目在树中存在路径,则直接建立一个新节点</li>
<li>在建树的过程中附加一个Header Table表,该表就是一维频繁项集,同时表中的元素含有指向树中第一次出现同名节点的指针</li>
<li>树中节点都含有指向下一个同名节点的指针</li>
</ul>
<p><img src="/FPpic/fp02.png" alt=""></p>
<p>为了便于对整棵树进行遍历，建立一张项的头表（an item header table）。这张表的第一列是按照降序排列的频繁项。第二列是指向该频繁项在FP-tree中节点位置的指针。FP-tree中每一个节点还有一个指针，用于指向相同名称的节点：</p>
<p><img src="/FPpic/fp03.png" alt=""></p>
<p>d.挖掘FP树</p>
<ul>
<li>从 Header Table中的最后一个项目开始,查找在树中的同名节点,并把所有同名节点的支持度相加,如果总和超过了阀值,就输出该节点作为频繁项集</li>
<li>然后从每一个同名节点,往上遍历到根节点,得到一条路径</li>
</ul>
<p><img src="/FPpic/fp04.png" alt=""></p>
<p><img src="/FPpic/fp05.png" alt=""></p>
<ul>
<li>把上面得到的路径作为原始事务集,重新调用第一阶段的建<br>树过程,重新建立一棵FP树,不过这棵树是以Header Table<br>中的元素为根节点的,且每次递归调用建树的时候,根节点<br>项目叠加我们将p的前缀节点链&lt;(f:2)，(c:2)，(a:2)，(m:2)&gt;和&lt;(c:1)，(b:1)&gt;称为p的条件模式基（conditional pattern base）.我们将p的条件模式基作为新的事务数据库,每一行存储p的一个前缀节点链，根据第二节中构建FP-tree的过程,计算每一行记录中各种物品的支持度,然后按照支持度降序排列,仅保留频繁项集,剔除那些低于支持度阈值的项,建立一棵新的FP-tree,这棵树被称之为p的条件FP-tree</li>
</ul>
<p><img src="/FPpic/fp06.png" alt=""></p>
<pre><code><span class="string">ps:</span>从上图可以看到p的条件FP-tree中满足支持度阈值的只剩下一个节点(<span class="string">c:</span><span class="number">3</span>)，所以以p结尾的频繁项集有(<span class="string">p:</span><span class="number">3</span>)，(<span class="string">cp:</span><span class="number">3</span>)。
    由于c的条件模式基为空，所以不需要构建c的条件FP-tree。
</code></pre><ul>
<li>若上面建立好的FP树只有一个节点,并且其支持度大于给定<br>的支持度阀值,则输出该节点和根节点作为频繁项集</li>
<li>遍历完Header Table中所有项目,FP树挖掘完毕<h3 id="算法实现">算法实现</h3><h4 id="1-举例说明">1.举例说明</h4>1.数据格式</li>
</ul>
<p><img src="/FPpic/fp07.png" alt=""></p>
<p>2.数据说明</p>
<p>每一行数据为一位顾客所购买的所有物品,每一列为物品本身</p>
<p>3.代码实现：</p>
<pre><code>val conf = new SparkConf<span class="params">()</span>.setAppName<span class="params">(<span class="string">"FPGrowth"</span>)</span>.setMaster<span class="params">(<span class="string">"local[2]"</span>)</span>
  val sc = new SparkContext<span class="params">(conf)</span>
  def main<span class="params">(args: Array[String])</span>: Unit = {
    val transactions: RDD[Array[String]] = sc.textFile<span class="params">(<span class="string">"hdfs://master:9000/data/fpdata"</span>)</span>.map { x =&gt; x.split<span class="params">(<span class="string">"，"</span>)</span> }.cache<span class="params">()</span>
    val fpg = new FPGrowth<span class="params">()</span>
      .setMinSupport<span class="params">(<span class="number">0.4</span>)</span><span class="comment">//设置支持度为0.4</span>
      .setNumPartitions<span class="params">(<span class="number">10</span>)</span><span class="comment">//设置分区</span>
    val model = fpg.run<span class="params">(transactions)</span>
    model.freqItemsets.collect<span class="params">()</span>.foreach { itemset =&gt;
      println<span class="params">(itemset.items.mkString<span class="params">(<span class="string">"["</span>, <span class="string">","</span>, <span class="string">"]"</span>)</span> + <span class="string">", "</span> + itemset.freq)</span>
    }
    }
</code></pre><p>4.运行结果</p>
<p><img src="/FPpic/fp08.png" alt=""></p>
<p>ps:左边一侧为商品频繁项集或者项目,右侧数字为商品频繁项集或者项目出现的次数</p>
<h4 id="2-_实现目标">2. 实现目标</h4><p>购物篮分析,该过程通过发现顾客放人其购物篮中的不同商品之间的联系，分析顾客的购买习惯。通过了解哪些商品频繁地被顾客同时购买，这种关联的发现可以帮助零售商制定营销策略,比如一起被购买的商品可以尽可能的摆放在一起而有助于商家的捆绑销售.</p>
<h3 id="FP-Growth算法应用">FP-Growth算法应用</h3><p>关联分析是从大量数据中发现项集之间有趣的关联和相关联系。关联分析的一个典型例子是购物篮分析。该过程通过发现顾客放人其购物篮中的不同商品之间的联系，分析顾客的购买习惯。通过了解哪些商品频繁地被顾客同时购买，这种关联的发现可以帮助零售商制定营销策略。其他的应用还包括价目表设计、商品促销、商品的排放和基于购买模式的顾客划分。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2016/07/03/FPGrowth/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://blucelyen.github.io/2016/07/03/FPGrowth/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2016/07/03/FPGrowth/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2016-06-16T09:42:19.677Z"><a href="/2016/06/16/k-means/">Jue., Jun. 16 2016, 5:42:19 pm</a></time>

  
    <h1 class="title"><a href="/2016/06/16/k-means/">K-Means算法</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>首先要来了解的一个概念就是聚类，简单地说就是把相似的东西分到一组，同 Classification (分类)不同， 对于一个 classifier ，通常需要你告诉它“这个东西被分为某某类”这样一些例子，理想情况下，一个 classifier 会从它得到的训练集中进行“学习”，从而具备对未知数据进行分类的能力，这种提供训练数据的过程通常叫做 supervised learning (监督学习)，而在聚类的时候，我们并不关心某一类是什么，我们需要实现的目标只是把相似的东西聚到一起，因此，一个聚类算法通常只需要知道如何<a href="http://wenku.baidu.com/link?url=D6Anniohd8zD0KF7HfUZEDeUxtXj6RwWt5UDYmDdvLIibuOWDhOSW1DVVugOAT9HOnr3rKL3rZ-UMLPexQngSQ9Jyv83X_yR33HgC-HQM-i">计算相似度</a>就可以开始工作了。ps:（不同的相似度计算方法应用于不同的场景，在聚类中应充分考虑使用哪一种相似度计算方法）。因此 clustering 通常并不需要使用训练数据进行学习，这在 Machine Learning 中被称作 unsupervised learning (无监督学习)。</p>
<h3 id="1-算法基本简介">1.算法基本简介</h3><p>k-means 算法接受输入量 k ；然后将n个数据对象划分为 k个聚类以便使得所获得的聚类满足：同一聚类中的对象相似度较高；而不同聚类中的对象相似度较小。聚类相似度是利用各聚类中对象的均值所获得一个“中心对象”（引力中心）来进行计算的。</p>
      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2016/06/16/k-means/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://blucelyen.github.io/2016/06/16/k-means/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2016/06/16/k-means/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2016-06-07T14:35:34.697Z"><a href="/2016/06/07/GraphX应用案例/">Mar., Jun. 7 2016, 10:35:34 pm</a></time>

  
    <h1 class="title"><a href="/2016/06/07/GraphX应用案例/">GraphX之微博用户热度和社交稳定度排名</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h2 id="1-_功能或场景介绍">1. 功能或场景介绍</h2><p>在社交网络中都存在用户之间的关注关系,可以通过这些关注关系转化为图,这个图的顶点为微博用户,用户之间的关注关系(用户A关注用户B,即A-&gt;B)就是图的边,此案例基于微博用户,用GraphX的PageRank算法进行排名(PageRank度量一个图中每个顶点的重要程度,假定从u到v的一条边代表v的重要性标签。例如,一个微博用户被许多其它人粉,该用户排名很高),与此同时计算图的入度和出度得到每个用户的微博粉丝数和关注数.除此之外还可以用GraphX的TriangleCount算法计算出每个用户的社交稳定程度(在微博上你关注的人也互相关注，大家的关注关系中就会有很多三角形，这说明社区很强很稳定，大家的联系都比较紧密；如果说只是你一个人关注很多人，这说明你的社交群体是非常小的。)</p>
<h2 id="2-_实验环境">2. 实验环境</h2><p>Hadoop2.6,Spark 1.4<br>
      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2016/06/07/GraphX应用案例/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://blucelyen.github.io/2016/06/07/GraphX应用案例/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2016/06/07/GraphX应用案例/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2016-06-06T11:12:28.158Z"><a href="/2016/06/06/ALS/">Lun., Jun. 6 2016, 7:12:28 pm</a></time>

  
    <h1 class="title"><a href="/2016/06/06/ALS/">ALS协同过滤算法</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h3 id="1-简介:">1.简介:</h3><p> 协同过滤常被应用于推荐系统，旨在补充用户-商品关联矩阵中所缺失的部分。MLlib当前支持基于模型的协同过滤，其中用户和商品通过一小组隐语义因子进行表达，并且这些因子也用于预测缺失的元素。Spark MLlib实现了交替最小二乘法 (ALS) 来学习这些隐性语义因子。在 MLlib 中的实现有如下的参数:</p>
<pre><code><span class="number">1</span><span class="class">.numBlocks</span> 是用于并行化计算的分块个数 (设置为-<span class="number">1</span>，为自动配置)。
<span class="number">2</span><span class="class">.rank</span> 是模型中隐语义因子的个数。
   ps: 用户根据对物品的一些属性对物品的评价情况，比如用户买一个商品是因为它美观，实用        
   那么美观，实用这两个因素就是模型中的隐语因子，即<span class="number">2</span>个隐语因子隐语义模型其实就是用户
   评价数据的因子分析，得到各个商品的主要因子，用的原理都是<span class="function"><span class="title">SVD</span><span class="params">(奇异值分解)</span></span>
<span class="number">3</span><span class="class">.iterations</span> 是迭代的次数。
<span class="number">4</span><span class="class">.lambda</span> 是ALS的正则化参数。
<span class="number">5</span>. implicitPrefs 决定了是用显性反馈ALS的版本还是用适用隐性反馈数据集的版本。
<span class="number">6</span><span class="class">.alpha</span> 是一个针对于隐性反馈 ALS 版本的参数，这个参数决定了偏好行为强度的基准。
</code></pre>
      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2016/06/06/ALS/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://blucelyen.github.io/2016/06/06/ALS/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2016/06/06/ALS/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2016-03-30T09:26:21.165Z"><a href="/2016/03/30/Coprocessor/">Mié., Mar. 30 2016, 5:26:21 pm</a></time>

  
    <h1 class="title"><a href="/2016/03/30/Coprocessor/">Hbase Coprocessor</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h2 id="1-Why_Hbase_Coprocessor?">1.Why Hbase Coprocessor?</h2><p>HBase作为列族数据库最经常被人诟病的特性包括：无法轻易建立“二级索引”，难以执行求和、计数、排序等操作。比如，在旧版(&lt;0.92)Hbase中，统计数据表的总行数，需要使用Counter方法，执行一次MapReduce Job才能得到。虽然HBase在数据存储层中集成了MapReduce，能够有效用于数据表的分布式计算。然而在很多情况下，做一些简单的相加或者聚合计算的时候，如果直接将计算过程放置在server端，能够减少通讯开销，从而获得很好的性能提升。于是，HBase在0.92之后引入了协处理器(coprocessors)，实现一些激动人心的新特性：能够轻易建立二次索引、复杂过滤器(谓词下推)以及访问控制等。<a href="http://blog.csdn.net/hljlzc2007/article/details/12652243">Coprocessor详细介绍</a>. </p>
<h2 id="2-应用场景">2.应用场景</h2><h3 id="2-1基于IDC用户网站访问记录系统设计与开发">2.1基于IDC用户网站访问记录系统设计与开发</h3><p>1.用Coprocessor实现查询符合某一时间段内访问网站的记录总数.</p>
<p>Tips:</p>
<p>HBase的coprocessor分为两类，Observer和EndPoint。其中Observer相当于触发器，EndPoint相当于存储过程。其中Observer的代码部署在服务端，相当于对API调用的代理。介绍这方面的文章不少,例如<a href="http://blog.csdn.net/hljlzc2007/article/details/12652243">Coprocessor详细介绍</a>.  但是关于EndPoint的使用。0.94.x之前使用EndPoint需要实现CoprocessorProtocol接口，而0.96.x的EndPoint改为用protobufs作为RPC的协议。<a href="http://blog.csdn.net/caisini_vc/article/details/5599468">ptotobuf协议详解</a>,下面将会讲解如何使用新版的Endpoint.</p>
      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2016/03/30/Coprocessor/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://blucelyen.github.io/2016/03/30/Coprocessor/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2016/03/30/Coprocessor/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2016-03-30T09:22:52.411Z"><a href="/2016/03/30/IDC/">Mié., Mar. 30 2016, 5:22:52 pm</a></time>

  
    <h1 class="title"><a href="/2016/03/30/IDC/">IDC用户网站访问记录系统设计与开发</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h2 id="1-设计思路">1.设计思路</h2><h3 id="1-1问题分析">1.1问题分析</h3><p>IDC用户网站访问记录系统设计与开发，顾名思义，本系统是为了分析用户某段时间内浏览网页的行为，我们需要计算哪些用户访问了哪些网页，对他们的行为进行分析，反映出网站的的热度等，程序设计思路理所应当是高效写入和查询数据。</p>
<h3 id="1-2设计目标">1.2设计目标</h3><h4 id="1-2-1_模拟数据写入模块">1.2.1 模拟数据写入模块</h4><p>在写入数据部分应该实现一个实时机制，在写入数据这一模块中,从数据在客服端产生到上传到hdfs再到将数据写入到Hbase这个过程涉及三个程序,第一个程序每隔一分钟生成模拟数据文件放在本地的一个文件夹中,第二个程序负责将生成的数据文件实时的上传到hdfs,第三个程序负责把hdfs上边的文件实时的写入Hbase中,由于考虑到实时,这三个程序构成一个实时的机制,数据产生即刻上传至hdfs并且即刻通过mapreduce直接写入Hbase。</p>
<h4 id="1-2-2_数据查询模块">1.2.2 数据查询模块</h4><p>查询部分本系统满足按时间段查询，按时间范围+ip范围查询完整记录，按时间范围+ip范围+协议类型查询完整记录，按时间范围+ip范围+协议类型+url域名查询完整记录。<br>
      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2016/03/30/IDC/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://blucelyen.github.io/2016/03/30/IDC/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2016/03/30/IDC/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2016-03-30T02:05:38.757Z"><a href="/2016/03/30/TriangleCount/">Mié., Mar. 30 2016, 10:05:38 am</a></time>

  
    <h1 class="title"><a href="/2016/03/30/TriangleCount/">TriangleCount(三角计数)</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>计算出关系图中，相互联系的三角结构（三顶点中任意两个顶点都可到达）个数。其个数衡量可用作个人或社区群体的稳定程度。</p>
<h3 id="1-_有向图转化为无向图">1. 有向图转化为无向图</h3><p>如下图所示，社交网络中的关注关系一般为有向图，这里需要转化为无向图。转化思路为：如果IF (A-&gt;B) or (B-&gt;A) THEN A-B。只要A与B在有向图中存在一条有向边，便认为A与B在无向图中存在边。（有向图弱化为无向图，即顶点间有关系即可）</p>
<p><img src="/triangleCount/01.png" alt=""><br>
      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2016/03/30/TriangleCount/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://blucelyen.github.io/2016/03/30/TriangleCount/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2016/03/30/TriangleCount/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>

<script src="/js/jquery.anystretch.min.js" type="text/javascript"></script>
<script src="/js/cover.js" type="text/javascript"></script>

    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div>
  
  &copy; 2016 Lyen
  
</div>
Powered by <a href="http://zespia.tw/hexo/" title="Hexo" target="_blank" rel="external">Hexo</a> and <a href="http://pages.github.com/" title="GitHub Pages" target="_blank" rel="external">GitHub Pages</a>

<div class="clearfix"></div></footer>
  
<script src="/js/jquery.imagesloaded.min.js" type="text/javascript"></script>
<script src="/js/gallery.js" type="text/javascript"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js" type="text/javascript"></script>




    <script type="text/javascript">
        (function(){

            $(window).scroll(function(){

                var scrollTop = $(window).scrollTop();
                if ( scrollTop >200 ){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
                } else{
                    $("#main-nav").removeClass('top_mode').addClass('normal_mode');
                }

            });

        })();
    </script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
  (function($){
    $('.fancybox').fancybox({
      'titlePosition': 'inside'
    });
  })(jQuery);
  </script>



    
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"BLuceLyen"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = 'http://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>



<script type="text/javascript">
  
  $(function(){

    $('.title').hover(
      function() {      
        $(this).stop().animate(
          {'marginLeft': '10px'}, 200
        );   
      }, 
      function() {       
        $(this).stop().animate({'marginLeft': '0px'}, 200);      
      
    });   

  });

</script>


</body>
</html>